/**  <b>Defining a new type of state variable in DDP</b>.

<OL>
<LI><h2>Introduction</h2>

<span class="n">DDP</span> comes with predefined state variables that can represent many of the processes in estimated models.  Examples include state variables that count past choices, track the duration of other states, or approximate a multivariate normal distribution.   But the set is by no means exhaustive and a serious user of <span class="n">DDP</span> will inevitably need include slight variations or wholly new kinds of variables.

<p>Although defining a new kind of state variable is not trivial, it can take a less time and be much less prone to error than coding from scratch and then adding variables on the fly.  <span class="n">DDP</span> is designed to add variables so it has stripped down what is needed to do so to a minimum.

<p>Below is an example of how to define a new state variable is provided. It shows both a very basic coding which can get the job done but which might be limiting in some ways.  So a second version of the code is shown which is more robust.

<p>
<UL>Several advanced elements of the Ox programming language are on display in this example.
<LI><a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefClasses">Classes</a>, <a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefPublic">Structs</a> and <a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefConstructor">constructor</a> routines
<LI><a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefDerClass">Derived classes</a> and <a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefVirtual">Virtual methods</a>
<LI>Assigning objects creates pointers (but copying scalars and matrices creates duplicates)</LI>
These features may be confusing to someone just starting to program in Ox, especially with no prior experience with object-oriented programming in an interpreted language.
</UL>

<LI><h2>Duplicate the State Variable Template File</h2>
<UL>
<LI>Pick a name for your new kind of State Variable.   It cannot have spaces or symbols except <em>_</em>. These instructions will refer to <code>&laquo;VarName&raquo;</code> for whatever name you chose.

<LI>Copy <code>niqlow/templates/DynamicPrograms/StateVariable.ox</code> to a file called
 <code>&laquo;VarName&raquo;.ox</code>.

 <LI>You can use your code in a program by either <code>#include</code> or  <code>#import</code>.  See the Ox documentation for more details about these two directives.  If you use  <code>#import</code> then you want to create two separate files,  <code>#import &laquo;VarName&raquo;.h</code> and <code>#import &laquo;VarName&raquo;.ox</code>.

<LI>Customize the template code for your variable, which is here:
<dd class="example"><code><pre>
Source: niqlow/templates/DynamicPrograms/StateVariable.ox
<object width="100%" height="300" type="text/plain" data="../../templates/DynamicPrograms/StateVariable.ox" border="1" ></object>
</pre></code></dd>
</UL>
<LI><h2>Code the <code>Transit()</code> method</h2>

To make the example look better, in this section we will suppose that you have decided to set &laquo;VarName&raquo; to be <q>MyStateVar</q>, and will use this wherever the name of the new derived class belongs.

The hard part is to code the transition for the variable.  It must be called <code>Transit()</code> because it will replace the virtual version from the base class.  It must also take an argument, a matrix <code>FeasA</code>.
<dd class="example"><strong>Possible Arguments Passed to Transit():</strong> Suppose the model has two binary choice variables, <var>i</var> and <var>j</var>.  Then the argument passed to <code>Transit()</code>  might look like this:
<pre><code>
  FeasA
  i    j
  0    0
  1    0
  0    1
  1    1</code></pre>
  </dd>

<h3>Example: Previous Occupation State Variable</h3>
<code>Transit()</code> must report back the transitions of an instance of the state variable from a given current point in the state space. <br>

Your variable would be one of the states, let's call it <code>y</code>.  You might have added it to the model this way:
<dd class="example"><pre><code>
mystate = new MyStateVar("y",4,&hellip;);
EndogenousStates(mystate);
</code></pre>
The <q>&hellip;</q> is not literal.  It is there because in this example the constructor variable will require other arguments.  Also, note that the state variable is stored in an Ox variable called <code>mystate</code>, but we will refer to it as <var>y</var>, which is the label given to it.</dd>

So once the problem is being solved some of the members of <code>mystate</code> might have these values:
<dd class="example"><code><pre>
mystate  {
   .L = "y"
   .N = 4
   .v = 0
   .pos = 1
   }</pre></code></dd>
That is, <var>y</var> takes on 4 different values (0,1,2,3).  At the current state it happens to have value <code>v=0</code>. It also happens to be the second state variable in the state vector (<code>pos=1</code>). <br>

To continue the example, we have to say what <var>y</var> is supposed to be.  Suppose it is an indicator for the <em>previous</em> value of <var>ix</var>.  For example, if <code>x</code> is an occupation code and the choice variable <code>i</code> indicates a choice to work, then <code>y</code> equals the occupation the person worked at last period if they did work.<br>

<dd class="example"><pre>
The <var>y</var> process as feasible states:<code>
   y' = 0 if i=0 or x=0
        x if i=1
</code>As a transition probability:<code>
 Prob(y' = z) = 1 if z = ix
                0 if z &ne; ix.</code></pre></dd>

The job of <code>Transit </code> is to determine the feasible values of next period and their probabilities. Because the transition probabilities are all 0 and 1, <code>MyStateVar</code> is classified as a <em>NonRandom</em> state variable.  This is a special case of an <em>Autonomous</em> process because the probabilities do not depend on the next values of the other states, such as <code>x'</code>.  If that were the case, the user has to create a `StateBlock` which will handle the transitions for multiple <em>coevolving</em> variables.<br>

However, notice that the arguments passed to <code>Transit()</code> allow the results to depend on the <em>current</em> action and state, which it does because of the presence of <var>i</var> and <var>x</var> in the expressions. For this reason, <var>y</var> is not <em>Exogenous</em>.  If it were its transition could be called once for the whole state space not at each point.

Let's continue the example.  Suppose  &laquo;VarName&raquo; has been added to a <em>finite horizon</em> model with three state variables <var>x</var>, <var>y</var> and <var>z</var>.  At some point in the process suppose the current value of the discrete state vector is:<dd class="example"><code><pre>
    State Vector
   x    y   z   a
   2    0   3   8</pre></code></dd>
The variable <code>a</code> is the age variable in the finite horizon.  Now we can represent the transition of <code>y'</code> at this particular state as follows:
<dd class="example"><code><pre>
FeasA              Prob(y')   trim 0 cols &rarr;     Prob(y')
 i    j     y'=  0   1   2   3             y'=0   2
-----------------------------------------------------
 0    0          1   0   0   0                1   0
 1    0          0   0   1   0                0   1
 0    1          1   0   0   0                1   0
 1    1          0   0   1   0                0   1
 </pre></code></dd>

<code>y</code> takes on four different values, but given that <code>x=2</code>, only two of those values are feasible next period, 0 or 2.   The overall transition routine in <span class="n">DDP</span> is smart enough to drop the columns of all zeros, but some computation can be reduced by trimming those columns inside <code>Transit()</code>.  Thus, we can focus on the trimmed 2-column representation of the transition probability.

<p><code>Transit()</code> returns the vector <var>y'</var> and the matrix <var>Prob(y')</var>.  It does this by returning an array of two elements.  See <a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefReturn">Ox doc entry for return</a>.

<p>Note that the first column of Prob(y') is simple the value <code>1-i</code>.  And the second column is simply <code>i</code>.

<LI><h2>Use the <var>constructor</var> to support <code>Transit</code></h2>

How will <code>Transit()</code> know that <code>x=2</code> currently?   And how will it know that <code>i</code> is in the first column of FeasA not the second?  This is where the object-oriented approach to building a dynamic programming model comes in handy compared to using vectors of values to represent the state vector.  <code>Transit()</code>  will know about <code>x</code> and <code>i</code> because it will be <em>constructed</em> to know them as the following code illustrates:

<dd class="example"><pre>Version 1. Source: niqlow/templates/DynamicPrograms/MyStateVar1.ox<code>
<object width="95%" height="350" type="text/plain" data="../../templates/DynamicPrograms/MyStateVar1.ox" border="1" ></object>
</code></pre></dd>

First, look at the code in Transit.  The expression <code>0~occup.v</code> generates, for the state above, the row vector <code>&lt;0 2&gt;</code>.  In general it tacks the current value of <code>x</code> onto 0 in order to produce <code>y' </code>.   Here the current value of <var>x</var> is not accessed from a vector of numbers (which from the view of this code has an unknown structure).  Instead it is accessed from a <em>public</em> member of a variable stored within the <code>MyStateVar</code> class.  That variable being <code>occup</code>.  It does not matter to <code>MyStateVar</code> whether <code>occup</code> has the label <q>x</q>.  It does not matter that <code>occup</code> happens to be first in the state vector.  It <em>does</em> matter, of course, that <code>occup</code> is indeed a state variable, and it has to know this before anything is done in the model.

<p>Therefore the <var>constructor</var> for <code>MyStateVar</code> requires the user to send the instance of some state variable class so that <code>occup</code> can be sure to <q>point</q> to the right variable.  State variables in a discrete DP must have a pre-specified number of values. This is enforced by having the base constructor for all state variables, <code>StateVariable::StateVariable()</code>, take two arguments, a label and an integer (the number of feasible values). SInce <code>MyStateVar</code> shadows the variable passed in <code>occup</code>, it can inherit the number of different occupations directly from it.  So the new base constructor passes that value through to the base constructor, which should be called, in some cases indirectly by calling the constructor of a class derived from StateVariable.   However, <code>NonRandom</code> is really a container so it does not have its own constructor.

<p>The second expression in the <code>return</code> statement is simply the Ox code to copy in <code>1-i</code> and <code>i</code>.  However, these are column vectors and they get their value from values from <code>FeasA</code>.  Which column of <code>FeasA</code>?  The answer is whichever column the <var>work</var> choice variable is stored in.  Again, the constructor requires the argument <code>work</code> which gets copied to the member with the same name.  And <span class="n">DDP</span> puts the position of the action in the action matrix in <code>pos</code>.  So whatever column it is any instance of <code>MyStateVar</code> will know which one it is.

<h3>How is Transit() used?</h3>

Knowing the feasible values and their transition probabilities for a single state variable is not sufficient to solve a DP problem.  The values of this state variable combine the feasible values of all other state variables to determine the possible states next period give the current state.  If the <var>value function</var> were stored as a multidimensional array (or matrix, which is not possible in Ox) then this state's possible values would simply be inserted into the right index for <var>V</var>, as in <code>V[x][y][z][a]</code>.    However, in Ox this would be inefficient, and without knowing ahead of time how many states will be added to the model it is not possible to write the code.  (There is no way in Ox or C to write something like <code>V[x]...[a]</code> to allow a dynamic number of dimensions.)

<code></code><p><span class="n">DDP</span> is designed to avoid this problem by storing <var>V</var> as a one dimensional vector regardless of the number of state variables.  The state is stored as a vector (internally), and the size of a vector can be determined dynamically.  Associated with the state vector is a vector of <var>offsets</var> or indices.  Multiply the state vector and the offsets to determine the index of the state in the V vector. Each state variable has an offset which depends on the other state variables and the number of values they take on.<p>

<span class="n">DDP</span> handles the offset.  The <code>Transit()</code> function only has to return the list of feasible values and their probabilities.   Actually, <span class="n">DDP</span> keeps track of several offset vectors to index different aspects of the overall solution algorithm.

The reason that the matrix of feasible actions has to be sent to Transit is because it is method of the state variable not the DP problem.  A node in the state space has access to its feasible choice set, but the state variable is a separate independent object.  Any aspects of the model that the transition needs to know about should be defined as members of its class.  For example, if the transition for state <code>s</code> depends on the current value of another state <code>x</code> then it should be sent and stored when the variable is created.

<LI><h2>Make sure <span class="n">DDP</span> knows about the dependencies</h2>

<span class="n">DDP</span> must know about the state variable <code>occup</code> and action variable <code>work</code>.  How?  This is done by using the `DP::EndogenousStates` and `DP::Actions` routines.

<dd class="example"><pre>Code Segment showing use of <code>MyStateVar
    static decl i, x, mystate;
    x = new StateVariable("x",4);
    i = new ActionVariable("i",2);
    mystate = new MyStateVar("y",x,i);</code></pre></dd>


<LI><h2>Make the code robust</h2>
To catch errors it is helpful to check the arguments sent to the <var>constructor</var>.  Although most mistakes in passing arguments would generate errors once the code starts running, the error may not occur until much later than when <code>MyStateVar</code> is called.  Even when using the variable for yourself it is useful to check the inputs.  If others will build on your code then it is very helpful for them to develop code quickly.

The key is that the arguments must be of the right type.  The Ox function <code>islcass()</code> is very useful here, because it checks that the arguments are derived from the correct base class (or the correct intermediate class).

Finally, the transit code can be made a little better.  In particular, for the interpretation given so far the <var>x</var> variable takes on the value 0.  This might be code for not being associated with any occupation, which is fine.  But suppose you want this variable to handle the case that a person always has an occupation.  Then <var>y=0</var> is ambiguous. It could mean the person did not work last period or they did work but in the occupation coded as 0.  The problem is that state variables always take on the values 0 to <code>N-1</code>, at least when using the <code>v</code> member.

You can resolve this by referring to the <code>actual</code> member of <code>occup</code>, not <code>v</code>.  Then, if real occupations are not coded as 0 to <code>N-1</code> but 1 to <code>N</code> (or any other set of values, then the ambiguity in coding <var>ix</var> can be resolved.  Note that <code>actual</code> is by default the same as <code>v</code>, but the user can specify the optional `StateVariable::Update` method to code <code>actual</code>.

<dd class="example"><pre>Version 2. Source: niqlow/templates/DynamicPrograms/MyStateVar.ox<code>
<object width="95%" height="350" type="text/plain" data="../../templates/DynamicPrograms/MyStateVar.ox" border="1" ></object>
</pre></code></dd>

<LI><h2>Duplicates versus Pointers</h2>

Ox does some <em>very</em> subtle things with memory.  To understand it requires some understanding of the C programming language, including unions of structures.  Quoting two parts of the Ox documentation:
<blockquote>Note that Ox <b>assignment of arithmetic types and string type</b> implies <em>copying</em> over the contents from the right-hand side to the left-hand side.<p>
Ox accesses an object through a<em> reference </em>to the object which is created using the new operator. An object is removed from memory using the delete operator (<em>if there is no matching delete, the object will exist until the program terminates</em>).
</blockquote>

These details are important as these lines of Ox code illustrate
<dd class="example"><pre>Source: niqlow/doc/examples/classreference.ox<code>
<object width="95%" type="text/plain" height="250" data="../../doc/examples/classreference.ox" border="1" ></object>
</code><em>Produces</em>
Source: niqlow/doc/examples/classreference.output.txt<code>
<object width="95%" height="200" type="text/plain" data="../../doc/examples/classreference.output.txt" border="1" ></object>
</code></pre></dd>

That is, in the first three lines <code>b=a</code> and then changing <code>b</code> does not change the value of <code>a</code>.  However, changing the member <code>v</code>  <em>does</em> change the corresponding value of <code>a</code>.<p>

In the first three assignments, Ox <em>clones</em> the right hand side of the assignment.  But when assigning a class a clone is not made.  Instead, a <em>reference </em>  or <em>pointer</em> to the class is made. So so accessing the member of the reference is equivalent to accessing the member of the assigned class.<p>

Returning to our example, this means  that   <code>this.occup  = occup;</code>  does not duplicate the state variable passed as an argument.  It creates a reference to it.  This is both powerful and dangerous.  It means that <code>MyStateVar</code> can mess up the <code>x</code> variable, which should be controlled by <span class="n">DDP</span>. But it also means that as <span class="n">DDP</span> manipulates <code>x</code> the other variable <code>mystate</code> is informed automatically, without <span class="n">DDP</span> needing to know that <code>y</code> depends on the value of <code>x</code>.

Also note that the <code>new</code> operator allows separate instances of <code>MyStateVar</code> to be created and passed different variables to track.  Because <code>occup</code> and <code>work</code> are <em>not</em> declared as <code>static</code> members, each instance has its own space for these variables.  So they can be different values not pointers to the same space.

<LI><h2>Why matrices for actions but not states? </h2>

It has been emphasized a few times that the user's code does not need to handle state variables in vectors.  So why is it required to handle actions stored as a matrix?  Here the issue is <a href="http://www.doornik.com/ox/oxtutlan.html#ox_tutlan_opt">computational speed</a> within an interpreted language like Ox and Matlab.  Namely, nested Ox loops induce a computational overhead that nested loops in compiled languages like C and FORTRAN do not.  <p>

The innermost loop of nearly all discrete dynamic programming solution algorithms is a choice over finite options.  Requiring the user-defined <code>utility()</code> and <code>Transit()</code> methods to handle the matrix of feasible actions means this inner loop can be handled with native Ox matrix routines.  Avoiding a layer of nested loops can speed up code considerably in an interpreted language like Ox.<p>

<LI><h2>What else?</h2>

<UL>
<li>Coding a new StateBlock</li>
<li>Allow actual values to depend on parameter values</li>
<li>Allow transition probabilities to depend on parameters</li>
</UL>
</OL>
**/ 