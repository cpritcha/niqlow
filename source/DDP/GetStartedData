/** Relating data to a DDP analysis.

@sortkey BAB
<blockquote>See <a href="Outcomes.ox.html">Outcomes</a> for more details and explanation.  And see <a href="../../examples/RustEmet1987mle.ox.html">Rust Emet 1987 mle</a> for an example of using external data.</blockquote>
<div class="page-break">
<h1>A small example based on simulated data </h1>
<blockquote>See <code>GetStartedData.ox</code> for the code, which is also displayed with output below.</blockquote>
<h2>This example is based on the <code>Search</code> model described in <a href="GetStarted.ox.html">Get_Started</a>.  </h2>
<DT>Through the magic of <a href="http://www.doornik.com/ox/oxsyntax.html#ox_syntax_RefDerClass">derived classes</a> the very simple search model used in GetStarted can be extended without touching the existing code or copying it to a new file and modifying.</DT>  The original code is <code>includ</code>ed (or if it had been split into <code>.h</code> and <code>.ox</code> files, <code>imported</code>) and a new class is derived from the <code>Search</code> class.
<pre>#include "GetStarted.ox"
struct SearchData : Search {
	enum{N=10,MaxOb=20}
	static decl u, simdata;
	static Run();
	}</pre></DD>
<DT>The <code>SearchData</code> class adds two members to the for data operations along with some pre-defined constants for the number of simulations to perform.  The static <code>Run()</code> procedure will do the work.</DT>
<DT>Next the user wishes to record realized utility as an auxiliary variable.  To do this create a new class:</DT><DD>
<pre>struct RealizedUtility : AuxiliaryVariable {
	RealizedUtility();
	Realize(const q,const y);
	}</pre></DD>
<DT>The constructor simply has to call the base constructor and send a label.  (It could do other things of course.)</DT><DD>
<pre>RealizedUtility::RealizedUtility() { 	AuxiliaryVariable("U"); 	}</pre>
Auxiliary variables need to provide a <code>Realize()</code> function, which will be called only when simulating data (or in econometric estimation that involves matching predicted outcomes). </DD>
<DT>The first argument is the realized point in the state space (&theta;).  The second is the current realized outcome.  This allows the auxiliary variable to access everything else.</DT>
<DD><pre>RealizedUtility::Generate(const q,const y) {
	v = q->Utility()[y.ind[onlyacts]];
	}</pre>
Since `AuxiliaryVariable` is derived from `Quantity` it has a current member, <code>v</code>.  The job of <code>Generate()</code> is to set <code>v</code> for other aspects of the code to use.  This means the variable can be sent to `CV`() after the call to <code>Generate()</code> In this case, the auxiliary outcome calls <code>Utility()</code> and extracts the element of the vector returned that corresponds to the realized action.  </DD>
<DT>The work will be done by <code>Run()</code>.</DT>
<DD><pre>SearchData::Run()	{
  Search::Run();
  AuxiliaryOutcomes(u = new RealizedUtility());
  simdata = new DataSet("Search Data",meth);
  simdata -> Simulate(N,MaxOb,zeros(NN),TRUE);
  simdata -> Print(0);
  simdata -> Observed(a,UseLabel,p,UseLabel,d,UseLabel);
  simdata -> Mask();
  println(exp(simdata -> EconometricObjective()));
  simdata -> UnObserved(p);
  simdata -> Mask();
  println(exp(simdata -> EconometricObjective()));	
  }</pre>
 <h2>Line-by-line explanation of <code>SearchData::Run()</code></h2>
 <DT>The first line calls <code>Run()</code> for the base <code>Search</code> class.  </DT>
 <DD>That is, two different routines called <code>Run()</code> are available in <code>SearchData</code>: the one defined above and the one inherited from the parent class (and discussed in GetStarted).  The prefix <code>Search::</code> is required to access the latter. (If SearchData did not have its own version the prefix is not required but could be kept to make the reference explicit).  </DD>
 <DD>As discussed in <a href="Get_Started.html">Get_Started</a>, the parent run routine sets up the model, solves it and prints out the value function.</DD>
<DT>To simulate the model a `DataSet` object is created and stored in a variable, <code>simdata</code>  </DT>
<DD>The first argument is a name to associate with the data set and the solution method to use during simulation or estimation.  (The member <code>meth</code> was set by the parent <code>Search</code>.)  You can pass <code>0</code> as the second argument if no method is required.  (In this case that would be acceptable because <code>Search::Run()</code> solved the model already and no parameters are going to be changed to require re-solution.)</DD>
<DT>A note on the repeated use of <code>simdata-&gt;</code></DT>
 <DD>This is required because <code>Run()</code> belongs to SearchData so the DataSet methods must be called for the object, in this case stored in <code>simdata</code>.<DD>
 <DD> Alternatively, a derived <code>DataSet</code> class could be created and then a method called once for the object without the <code>obj-&th;</code> code.  However, this would then require the prefixing references to <code>meth, a, p, d</code> by <code>SearchData::</code>.</DD>
 <DD> <b>Exercise:</b>, rewrite the source code in this manner.</DD>
<DT><code>Simulate()</code> generates the simulated sample by applying the conditional choice probabilities and transitions to initial states. </DT>
<DD>The simulated panel will consist of <code>N=10</code> paths of the search model, each of maximum length <code>MaxOb=20</code>.  Since the model has a terminal state, then any path may end before the maximum length.  If there were not terminal conditions then the second argument determines how long each path really is.  </DD>
<DD>The third argument is a matrix of initial state vectors to use in the simulation.  In this case a single state vector is sent.  Since the model is stationary (<code>t=0</code>), and the non-absorbing state happens to be <code>d=0</code>, then sending a vector of zeros is appropriate for initial conditions.  But in other situations this may not be the desired or well-defined initial state.  </DD>
<DD>The fourth argument being TRUE indicates that when a terminal condition (<code>d=1</code>) is reached that outcome should not be included in the simulated path. The effect is to trim outcomes that are not needed.  Once the agent has accepted a price the process is done.  So the next state with <code>d=1</code> is redundant for estimation purposes.</DD>
<DT>Note:  <code>DataSet</code> class does not have a <code>Simulate()</code> method of its own. </DT>
 <DD>Since <code>DataSet</code> is derived from the `Panel` class the command <code>simdata-&gt;Simulate(&hellip;)</code> is equivalent to <code>simdata-&gt;Panel::Simulate(&hellip;)</code>. This also means that the user could have made <code>simdata</code> and Panel object instead, if simulation was all that was required, but the data manipulation coming next require a <code>DataSet</code> object.</DD>
<DT><code>Print(0)</code> constructs a matrix representation of the data set and prints it to the output screen or log file.</DT>
  <DD>If <code>Print()</code> had been sent a file name with a valid extension then the simulated matrix would have been saved to a file (e.g. such as <q>sim.data</q> or <q>search.xls</q>).  </DD>
  <DD>A panel of paths is really a multi-leveled linked list of outcomes.  This makes it possible to write general purpose routines for analyzing the data under various assumptions, such as the likelihood of the panel when some states are unobserved.  </DD>
  <DD><code>Print()</code> calls <code>Flat()</code> to flatten this data structure into a <q>long</q> matrix, one row for each outcome and one column for each element of the full outcome Y* (except for the pointers to other outcomes).  Columns for path id and simulated time are added.  <code>Flat()</code>is itself a recursive task that builds up the matrix by processing fixed panels, paths and outcomes recursively.</dd>
<DT>`DataSet::Observed`() allows the user to control which parts of the outcome is seen in data (and available to econometric methods) and which are missing and require integration over.</DT>
<DD>By default nothing is observed, so the user must explicitly add variables to the observed list.  State variables that are `Fixed`, are placeholders that take on only one value, so they are implicitly observed.  These are marked as <code>force0</code> so that if reading in from external data the values will be filled in and they do not have to be explicitly observed.</DD>
<DD><code>DataSet::Observed()</code> takes one or more <em>pairs</em> of arguments.  The first in the pair is the state, action or auxiliary variable that is observed.  The second is either the label for that variable's column in external data or the index of that column.  The code <code>UseLabel</code> means that the same label is used in the data as stored internally for the variable.  (When using simulated data this second argument is not used, but if the data were save to disk and read back in to a different DataSet object it would be best to use <code>UseLabel</code> because it is used for the column labels.,</dd>
<DT>Since the code is working with simulated data, the data set already has the full outcome <code>Y*</code> in memory.  </DT>
<DD>When reading in external data, the observability of variables is specified <em>ex ante</em> and then the observable data is read in using <code>`DataSet::Read`(const filename)</code>.  But here, observability is specified <em>ex post</em>.</DD>
<DD>With simulated data, the user must apply `DataSet::Mask`() before sending the data to an econometric method.  When reading in external data the mask is applied internally by `DataSet::Read`().</DD>
<DT>Masking accounts for unobservability using a fairly complex process (which will be documented more completely in later releases.</DT> 
 <DD>Essentially missing observations spawn loops over all possible values when processing the outcome.  And the model's probabilistic elements must be used to weight the paths.  </DD>
 <DD>Further, procedures such as likelihood computation is carried out using backwards recursion not the usual forward recursion.  </DD>
<DD>Unless the DataSet <code>Volume</code> is set to <code>SILENT</code> the masking method will print out a table summarizing the observability of the total outcome.</DD>
<DT>DataSet has a virtual method, `DataSet::EconometricObjective`().  The default is to compute and return `Panel::LogLikelihood`()</DT>
 <DD>The user can derive their own DataSet class and replace it with an alternative procedure (and other built in objectives, such as GMM, will be provided in later releases).</DD>
<DD> Since it is log-likelihood it is easier to check the <code>exp()</code> in this small example .  As with all `Objective`s within <span class="n">FiveO</span>, it turns a vector of values that `Algorithm`s will sum up or use directly to compute Jacobians as needed.</DD>
<DT>Once data is masked or read in from an external source the value of any variable that was not marked as observed for force0 is now lost even if it were observed originally.  </DT>
<DD>So it is not possible to undo <em>un</em>observability within a program and a single data set.  A second data set can be created without different observability and read in from the same source. (And simulated data could be saved using <code>`Panel::Print`(filename)</code> and read into a new data set.)</DD>
<DD>However, it is possible undo observability, as the next line illustrates.  In the first evaluation of the likelihood the offered price, <em>p</em> was treated as observed.  Now, that mark is undone by sending the variable <code>p</code> to `DataSet::UnObserved`() and re-masking the data.  The next likelihood will integrate out the offered price.</DD>
<DT>A note on observing the terminal state <code>d</code>.  </DT>
<DD>Since the terminal condition <code>d=1</code> was censored from the simulated data all the observations have active searchers.  However, <code>Mask()</code> does not know this so unless <code>d</code> is marked as unobserved.</DD>
<DD>This creates a problem for rejected offer observations (<code>a=0</code>), because that is feasible when <code>d=1</code>.  Thus, the built in log-likelihood will integrate over <code>d=0</code> and <code>d=1</code> when offers are rejected unless <code>d</code> is marked as observed.  The user should remove <code>d,UseLabel</code> from the observed list and see the implications of this change.</DD>
<DD>A later version of <span class="n">niqlow</span> may address by allowing terminal states to have empty feasible action sets.</DD>
<h2>Output</h2>

<DT>Output produced by running GetStartedData.ox is here:</DT>
<dd><pre>Source: <a href="../../examples/output/GetStartedData.txt">niqlow/examples/GetStartedData.txt</a>
<object width="75%" height="200" type="text/plain" data="../../examples/output/GetStartedData.txt" border="1" ></object></pre></dd>
<DT>First, note that the same output is produced as GetStarted.ox, because <code>Search::Run()</code> is called.</DT>
<DT>Next, the simulation is conducted.  Because a `Method` object was passed to the DataSet the value function was solved again, with the same results.</DT>
<DT>As requested, the simulated data is printed as a flat matrix.</DT>
 <DD>The column labeled <code>path</code> is an identifier for the realization, and since 10 were requested the ID goes from 0 to 9.</DD>
 <DD>Since the probability of accepting an offer is 0.7, most simulated paths will end after one period (<code>t=0</code>).   Paths 2 and 7 include rejection of high prices in the first period followed by acceptances in the next period.  Also, note that terminating states <code>d=1</code> are excluded as requested.</DD>
 <DD>The final column of the matrix is the realized utility, which is the auxiliary variable.  </DD>
 <DT>The observability of variables is summarized next, in three rows for each aspect of Y*.</DT>
<DD>The program marked <code>a, p, d</code> as observed.</DD>
 <DD>Five aspects of the outcome are fixed (only take on the value 0), so <code>force0</code> is equal to 1 for them. </DD>
 <DD>Since the data are simulated rather than external, each column index is -1. </DD>
 <DT>When <code>EconometricObjective</code> is called the method is used and the model is again solved (in this case unnecessarily because nothing has changed).</DT>
 <DD>The output of the call is a 10x1 vector of log-likelihoods for each IID outcome: that is, each path.  The exponent is taken before printing it out in order to get back to a probability (in levels).</DD>
 <DD>The fact that each likelihood is exactly 1.0 may be unexpected.  But recall, in this simple model there is no continuous shock &zeta; and no <em>ex post</em> smoothing of choice probabilities. So the choice probability &Rho;* is 1.0 for the optimal choice and 0 otherwise.  Since the data are simulated the optimal choice is always chosen, and <em>since p is treated as observed</em> the likelihood conditions on its value.</DD>
 <DD>If external data were read in that included an inconsistent choice (such as rejecting a price of 2), then the likelihood of that observation would be 0.0.  (As a modern mathematical language, Ox represents <code>log(0)</code> as <em>-&infty;</em>, and <code>exp(-&infty;)</code> as 0.</DD>
 <DT>Next, the observability of <code>p</code> is undone and the objective is computed again.</DT>
 <DD>The model is resolved, again with the same results and in this case unnecessarily.</DD>
 <DD>The new observability is summarized.  As noted above, it is not possible to reverse unobservability within a data set, since the observed values are destroyed.  But there is no issue with removing <code>p</code> from the observed list and re-masking the data.</DD>
 <DD>Now, with prices as treated as unobserved, the model is probabilistic.  The model's chance that <code>a=0</code> is the probability that realized <code>p&ge;7</code>, or 3/10.  The chance of acceptance is 0.7, and for the 8 paths for which the first offer was accepted this is indeed the computed likelihood.  This demonstrates that <span class="n">niqlow</span> is able to account for unobservability of states (or actions) based on the model set up and the specified information about outcomes, which are treated independently of the model output and the full outcome Y*.</DD>
 <DD>For the two observations where the first price is rejected the likelihood is <em>0.21 = 0.7 &times; 0.3</em>.  This demonstrates that a panel of realizations from a single DP is handled properly.</DD>
 
**/
