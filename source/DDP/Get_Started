/**Start to use <span class="n">DDP</span> by following a simple example.

@sortkey AAA

Design and solve a DDP model of <em>searching for a low purchase price</em>.

<OL class="contents">CONTENTS
<LI><a href="#A">Define the model</a>
<LI><a href="#AB">Translate the model into <span="n">DDP</span> terms</a>
<LI><a href="#B">Code the model and solution method</a>
<LI><a href="#C">Run the code and look at the output</a>
<LI><a href="#N">Notes</a>
</OL>

<OL class="body">
<a name="A"><LI>Define The Model</LI></a>
<OL class="section">
<LI>A person must purchase an item and searches, potentially forever, for an acceptably low price.
<LI>Each period a price <var>p</var> is drawn from the discrete set <var>{0,1,2,...,N&oline;}</var>, IID across time and equally likely:
	<DD><pre><var>Prob(p&prime; = z) = &Rho;(z) = 1&frasl;N</var> for <var>z &in; {0,...,N&oline;}</var>.</pre>
	p&prime; is the price next period and &Rho;() is its transition.  <sup><a href="#n-1">note</a><a name="s-1">&nbsp;</a></sup></dd>
<LI>While searching the person chooses <var>a</var>, where <var>a=1</var> means buy at the offered price and <var>a=0</var> means reject and keep searching.
<div class="page-break"> </div>
<LI>The state <var>d=0</var> means still searching, and <var>d=1</var> means a price has been accepted:
	<dd><pre><var>d' = a</var>  &hArr; &Rho;(d';a,d) = I{d'=a}.</pre> And <var>d=1</var> is a terminal absorbing state.</dd>
<LI>Utility equals realized costs: search costs,  &lambda;&gt; 0, and the price paid if purchased:
	<dd><pre><var>U(a,p,d) = -(1-d)[ &lambda; + ap ]</var>. </pre></dd>
<LI>Future returns are discounted by &delta;&lt;1.
</OL>

<a name="AB"><h2><LI>Translate the model into <span class="n">DDP</span> notation</LI></h2></a>
<UL>
<LI>The <b>action</b> vector contains a single variable: <var>&alpha; = (a)</var>
<LI>The <b>exogenous</b> vector &epsilon; contains one variable, <var>&epsilon; = (p)</var>, a <code>`SimpleJump`</code>.
<LI>The <b>endogenous</b> vector is then <var>&theta; = (d t)</var>.
<DD><var>d</var>, a <code>`LaggedAction`</code>.  <var>d=1</var> is in the terminal set,
<span class="o">&Theta;</span></DD>
<DD>The <b>clock</b> is stationary, or predefined type <code>InfiniteHorzion</code>, so the current time is always (<code>t=0</code>).</DD></LI>
<LI>The <b>semi-exogenous </b> vector &eta; and the <b>group</b> vector &gamma; each contain nothing  (so <span class="n">DDP</span> puts a fixed states in them as placeholders).
<LI><b>Utility</b> <DD><pre><var>U(&alpha;,&epsilon;,&eta;,&theta;,&gamma;) = -(1-d)[ &lambda; + ap ]</var> .</pre></DD>
</UL>

<a name="B"><h2><LI>Code the model in <span class="n">DDP</span></LI></h2></a>

<DT>The full DDP source code is in <a href="../../examples/GetStarted.ox">niqlow/examples/GetStarted.ox</a>.
<DT>Declare a class derived from `Bellman` to represent the problem.<DD><pre>
 1:   #import "DDP"
 2:   class Search : Bellman {
 3:   		enum{Noff=10}
 4:   		static 	const		decl 	lam = 2.3;
 5:   		static 	  		decl 	p, d, a;
 6:   		static 	Reachable();
 7:   		static 	Run();
 8:   		 	Utility();
 9:		}
</pre></DD>
Usually the code above would appear in a separate header (<code>.h</code>) file, but in the source code it simply appears at the top of the <code>.ox</code> file.
<div class="page-break"> </div>
<DL>Line-by-line Description
<DT>1. Import
<DD>The Ox code relies on the <span class="n">DDP</span> package, so import the compiled code and header information for it. </DD>
<DT>2-9. Class Declaration</DT><br>
A user's DP model is represented by a <code>class</code> (or <code>struct</code>). The class name is <code>Search</code>. It is <em>derived</em> from an underlying class, <code>`Bellman`</code>.   The code inside <code>{}</code> declares variables (data members) and functions (method members) that are needed to code the model.   Each <q>instance</q> of a `Search` created while the program executes will represent one point in the state space. Aspects of the model that are shared across points in the state space are stored as <em>static</em> members of the class. Non-static elements are called <em>automatic</em> in Ox, but something is automatic by default unless the tag <code>static</code> appears when it is declared.<sup><a href="#n0">note</a><a name="s0">&nbsp;</a></sup>
<DD>3: The number of offers <var>N</var> is an <em>enumeration</em>, a way of storing integer constants that Ox shares with C. </DD>
<DD>4: The parameter &lambda; is stored as a static constant (its value is fixed at declaration).  More powerfully it could be represented as an object of the `Parameter` class discussed later.
<DD>5: Three data members are declared static but variable (their value can change after the object is created).  These store the state variables <var>p</var> and <var>d</var> and the action variable <var>a</var>.</DD>
<div class="page-break"> </div>
<DD>6: A function associated with an object is called a <code>method</code>.  <span class="n">DDP</span> requires two methods.  One tells <span class="n">DDP</span> that a particular point in the state space is reachable from a feasible path (or not).  In <code>Search</code> it is called <code>Reachable()</code>.  It must be a <code>static</code> method.</DD>
<DD>7:  The method <code>Run()</code> is not required, but it will be designed to set up and solve the model.
<DD>8:  The second required  <code>method</code> cannot be <code>static</code>, and must have the name and declaration <code>Utility()</code>.  It returns the one-period payoff.</DD>
</DL>
<div class="page-break"> </div>
<DT>Define the required functions for the model</DT><DD><pre>
23:	Search::Reachable()	{
24:		return new Search();
25:		}
26:	Search::Utility()  {
27:		return -(1-CV(d))*(lam + CV(p)*aa(a));
28:		}</pre></DD>
<DD>If it is unnecessary to trim infeasible states from &Theta; (to conserve memory) then <code>Reachable()</code> is very simple.  When called it returns a new point in the endogenous state space, &theta;.</DD>
<DD>Utility returns a column of values for feasible actions.  It gets the current value of state variables by sending their objects to the <code>`CV`()</code> function.</DD>
<div class="page-break"> </div>
<DT>Define the code to set up and solve the model<DD><pre>
10:  Search::Run()	{
11:  		Initialize(Reachable,FALSE,0);
12:  		SetClock(InfiniteHorizon);
13:  		SetDelta(0.99);
14:  		Actions(a = new ActionVariable("a",2));
15:  		EndogenousStates(d = new LaggedAction("d",a));
16:  		d->MakeTerminal(1);	
17:  		ExogenousStates(p = new SimpleJump("p",Noff));
18:  		CreateSpaces();
19:  		decl EMax = new ValueIteration(0);
20:  		EMax.Volume = LOUD;
21:  		EMax -> Solve(0,0);
22:   }</pre></dd>
<div class="page-break"> </div>

<DL>Line-by-line Description
<DT>Set Up the Problem
<DD>11. The user's code must also call the <code>Initialize()</code> method before setting up or solving the model.  <sup><a href="#n4">note</a><a name="s4">&nbsp;</a></sup> The first argument sent to <code>Initialize</code> is the name of the method that indicates if a state is reachable or not.  Note that <code>Reachable()</code> has been declared above but not yet defined.</DD>
<DD>Code to set up the model must appear after <code>Initialize()</code> and before the <code>CreateSpaces()</code> method is called.
<DD>12: Every DDP model has a clock. There are several predefined clock types, and the user can create their own if necessary.  <code>InfiniteHorizon</code> is an enumeration like <code>Noff</code> in the file above which <code>`DP::SetClock`()</code> uses to create the right kind of clock. </DD>
<DD>13: Every DDP model has a discount factor &delta;.  <code>`DP::SetDelta`()</code> sets its value, which is constant here but could be set to a variable `Parameter`..</DD>
<div class="page-break"> </div>

<DD>14:  The action <var>a</var> is an instance of the <code>`ActionVariable`</code> class.  It is not an ordinary <code>integer</code> as it might be coded in FORTRAN or C.  By making it an instance of a class  <span class="n">DDP</span> can keep track of all the requirements of having a binary choice in the model without making the user do additional programming.  When it is created, the user gives the action a label and says how many different values are feasible for the variable, in this case <code>a.N=2</code>. This happens <em>inside</em> the call to `DP::Actions`(). DDP must know about the action variables in your model.  It cannot peer into the derived <code>Search</code> class and see that a variable <code>a</code> is there and stores an action variable boject.  On the other side, action variables cannot insert themselves into your model.  The routine <code>`DP::Actions`()</code> adds the argument(s) sent to it to the model, putting them in the action vector &alpha;.  <sup><a href="#n1">note</a><a name="s1">&nbsp;</a></sup></DD>
<div class="page-break"> </div>

<DD>15-16: Like the action, the state variables <var>d</var> and <var>p</var> are not just a place to store an integer nor a spot in a vector. State variables are objects of a class derived from the <code>`StateVariable`</code> class. States require more information than actions to be handled properly.   In the model <var>d</var> tracks the choice made in the previous period.  This kind of state variable appears in many models so a class for that kind of variable is predefined in <span class="n">DDP</span>: the <code>`LaggedAction`</code> class.  The action that <code>d</code> should track is sent as an argument when a <code>new</code> object of the class is created. <sup><a href="#n2">note</a><a name="s2">&nbsp;</a></sup>  The method <code>`DP::EndogenousStates`()</code> adds the arguments sent to it to to the &theta; vector. Recall that <code>d=1</code> is a terminal state.  <span class="n">DDP</span> must know this so that the value of reaching that state is taken from its utility not iterated on using Bellman's equation.  <code>MakeTerminal()</code> is a  <code>StateVariable</code> method that can take either an integer or a vector of integer values as its argument.  <code>d->MakeTerminal(1)</code> would not work if <var>d</var> had not be assigned a state variable in the previous line.</DD>

<DD>17: The state variable <var>p</var> takes on one of <var>p.N</var> different values with equal probability. In <span class="n">DDP</span> this is a <code>`SimpleJump`</code> state variable.  Since its transition  does not depend on the current state or actions, <span class="n">DDP</span> can be told this an <em>exogenous</em> state variable, reducing memory and computations.   </DD>

<div class="page-break"> </div>

<DT>Create the DP environment
<DD>18: Once all elements have been created and added to the model, the user's code calls <code>CreateSpaces()</code>.  <code>CreateSpaces()</code> uses all the information available about elements added to the model to create the state space, the feasible Action sets and many other aspects of the problem.  To conserve memory requirements and computational time <span class="n">DDP</span> does not create separate points for the exogenous elements of the state space (here <var>p</var>). It treats these separately and <q>attaches</q> values related to the exogenous states to the points in the endogenous state space, &Theta;</DD>

<DT>Solve the Model (and more)
<DD>19:  The model is separate from methods to solve it or use it in some way, including simulation and parameter estimation.  Solution methods are derived from the `Method` class, which itself is derived from the `Task` class.  Tasks are coded to go through the state space and do something at each point.  Tasks share the <code>static</code> aspects of the user's model, but they do not have the <code>automatic</code> variables that are specific to each point.  </dd>
<DD>The most straightforward method for solving a DP model is iteration on Bellman's equation, either until convergence with an infinite horizon or backwards from the final decision period in a finite horizon.  This solution method is coded as  `ValueIteration`.  The user creates an object of this type.  Other solution methods could be  new instance of it and then call the `ValueIteration::Solve`() method.  This will carry out the iteration, and since tasks know about static aspects of the model, such as the type of clock, <code>Solve()</code> will handle the details.  The two arguments <code>(0,0)</code> relate to controlling the solution method, but are talked about later.</dd>
<DD>Representing solution methods with different classes that are dynamic (do not rely heavily on static data) means that different solution methods can be applied to the same model and compared to each other.</DD>
</DL>

</DL>
<div class="page-break"> </div>

<UL><h3>Summary</h3>
<LI>A user DP model is derived from <code>Bellman</code> or another class derived from <code>Bellman</code>. The user code must always call <code>Initialize()</code> for the parent class.
<LI>Actions and state variables are instances of predefined classes or user-defined classes.  They are added the model using DP methods (functions).
<LI>Once all elements of the model have been added the user must call <code>CreateSpaces()</code> to set up the state space and other aspects of the model. The user's code must define a function that returns a <code>new</code> instance of their class which is passed to <code>CreateSpaces()</code>, which will call that function for each point in the state space &Theta;.
<LI>The user must provide a <code>Utility</code> method and a function.  This replace the <em>virtual</em> method in Bellman of the same name.
<LI>The model is solved by creating an solution object and calling the appropriate method (usually <code>Solve</code>).
</UL>

<a name="C"><h2><LI>Run the code and see the output</LI></h2></a>

The code in <code>GetStarted.ox</code> does not run on its own.  Like C, Ox needs to find a single routine called <code>main()</code> which is where execution starts.  Often <code>main()</code> is defined in a file on its own.  To run the code from there the <code>#include</code> directive can be used to bring other code into the program.

<dd class="example"><pre>Source: <a href="../../examples/GetStartedMain.ox">niqlow/examples/GetStartedMain.ox</a>.
<object width="75%" height="200" type="text/plain" data="../../examples/GetStartedMain.ox" border="1" ><p style="font-size:24pt"></object></pre>
<code>main()</code> does only one thing.  It calls <code>Run()</code> which does all the work. <sup><a name="s3"> <a href="#n3">note</a></sup>. From a command prompt in the examples directory (and assuming  <code>niqlow/include</code> is on the include path)
<pre>oxl GetStartedMain </pre></dd>
<div class="page-break"> </div>

<dd class="example"><pre>Source: <a href="../../examples/output/GetStarted.txt">niqlow/examples/GetStarted.txt</a>
<object width="75%" height="200" type="text/plain" data="../../examples/output/GetStarted.txt" border="1" ></object></pre>
By default DDP prints out information (you can control the amount by setting <code>DP::Volume</code>).  When the spaces are created a summary of the state variables, state spaces, action vectors, and feasible action sets is produced.  The <code>Vprint()</code> routine prints out information for each point in the endogenous state space &Theta;:  The value of state variables in &theta; EV(&theta;) and choice probabilities averaging over the exogenous states.  Since EV = -6.26 the searcher will accept any offer with a price below 6.26.  There are 7 such offers, 0 through 6, and each is equally likely.  So the probability that <var>a=1</var> is 7/10 or 0.7.  The rejection probability is 0.3.</dd>

<a name="N"><h2><LI>Notes</LI></h2></a>
<OL>
<LI><a name="n-1">N&oline; means <q>N-1</q>.  For more on notation see <a href="Guide.html">The Guide</a></a>. <a href="#s-1">Return</a>
<hr>
<LI><a name="n0">Here is a class with two static variables and one automatic.  Three new instances of it are created.  There are then three versions of <code>A.c</code> but still only two locations <code>A.a</code> and <code>A.b</code>.
<dd><pre>
class A {
        static decl  a, b;
        decl  c;
}
d = new A();
e = new A();
f = new A();</pre>
<code><table border="1" width="25%" cellpadding="3"><tr><th colspan="3">A<br> A::a, A::b</td></tr><tr><th>d</th><th>e</th><th>f</th></tr><tr><td>d.c</td><td>e.c</td><td>f.c</td></tr></table></code>
Note that <pre>
A::a  &equiv;  d.a  &equiv;  e.a  &equiv;  f.a.
A::b  &equiv;  d.b  &equiv;  e.b  &equiv;  f.b.
d.c !&equiv; e.c !&equiv; f.c
</pre>
However it is referenced, <code>a</code> and <code>b</code> refer to the same place.  On the other hand, each instance of A has a distinct <code>c</code>.  So there are 5 distinct storage locations, two shared and three specific to the instance of A.</dd>
<a href="#s0">Return</a>
<hr>
<LI><a name="n1">The fancy bit is that in Ox, like C and other languages, an assignment expression returns a value.  So v=6 stores 6 in v and returns 6 as a result.  print(v=6) will print 6.  A subtle that is further explained in other parts of the documentation is that Ox will return a reference to a so what Actions() stores is a pointer to a not a clone of a.</a> <a href="#s1">Return</a>
<hr>
<LI><a name="n2">Actually, this class is a great-granddaughter of <var>StateVariable</var>, because it is derived from the <code>Lagged</code> class which is derived from the <code>Deterministic</code> class derived from <code>StateVariable</code>.  Indeed, d and a are third cousins, because states and actions are both derived from an underlying Discrete class.</a> <a href="#s2">Return</a>
<hr>
<LI><a name="n3">Since <code>Run()</code> is static it can be called without referring to an instance of the class previously created with the <code>new</code> operator. there does not have to be an instance of the class.  In general a user will only call static elements of their model.  The DDP code will create instances of the class to represent states and process them internally.</a> <a href="#s3">Return</a>
<hr><LI><a name="n4"><code>Bellman::Initialize()</code> works only on static elements of the model, and these must be set before any instances of the model are created with <code>new</code>.  So it is not possible to put these tasks in the <q>constructor</q> for DP. The user may declare a <code>Initialize()</code> method if they expect the class (<code>Search</code>)  to be used as a base for other derived classes. Then <code>Search::Initialize()</code> would call <code>Bellman::Initialize()</code> and the prefix will be required to resolve the name.</a> <a href="#s4">Return</a>
</OL></OL>

**/
